{"id": 1, "type": "mcq", "question": "What does fin n mean in a Cryptol type constraint?", "options": ["n is a fixed number", "n is infinite", "n is a finite, known numeric type", "n is an integer variable"], "answer": "n is a finite, known numeric type", "concept": "type constraint"}
{"id": 2, "type": "mcq", "question": "The symbol # in M # 0b01 represents what operation?", "options": ["concatenation", "XOR", "padding", "bitwise AND"], "answer": "concatenation", "concept": "bit concatenation"}
{"id": 3, "type": "mcq", "question": "In the SHA3 spec, c = 2 * digest defines:", "options": ["output length", "capacity of Keccak", "security strength"], "answer": "capacity of Keccak", "concept": "capacity parameter"}
{"id": 4, "type": "mcq", "question": "What is the value of SecurityStrength if digest = 512?", "options": ["256 bits", "512 bits", "1024 bits"], "answer": "256 bits", "concept": "security strength"}
{"id": 5, "type": "mcq", "question": "What happens if digest = 200 in the SHA3 module?", "options": ["Type error: fails constraint", "Compiles but wrong hash", "Infinite recursion"], "answer": "Type error: fails constraint", "concept": "type constraint"}
{"id": 6, "type": "mcq", "question": "What does KBO::reverseBitOrdering do?", "options": ["Swaps byte order", "Reverses bit order within bytes", "Pads with zeros"], "answer": "Reverses bit order within bytes", "concept": "bit ordering"}
{"id": 7, "type": "mcq", "question": "Why does hashBytes use split?", "options": ["To split digest into bytes", "To divide message blocks", "To remove padding"], "answer": "To split digest into bytes", "concept": "byte alignment"}
{"id": 8, "type": "mcq", "question": "MessageUpperBound = inf means:", "options": ["There\u2019s no upper bound on message size", "Infinite digest length", "Infinite recursion"], "answer": "There\u2019s no upper bound on message size", "concept": "message size"}
{"id": 9, "type": "mcq", "question": "Keccak`{d=digest} means:", "options": ["Function call", "Type instance with parameter d", "Comment", "Module import"], "answer": "Type instance with parameter d", "concept": "parameterization"}
{"id": 10, "type": "mcq", "question": "The symbol % in (digest % 8 == 0) means:", "options": ["Modulo operation", "Bitwise AND", "Concatenation"], "answer": "Modulo operation", "concept": "numeric constraint"}
{"id": 11, "type": "short", "question": "Explain the purpose of the constraint (digest % 8 == 0) in the SHA3 parameter declaration.", "answer": "Ensures digest length is byte-aligned so hashBytes can output full bytes."}
{"id": 12, "type": "short", "question": "Why is reversing bit ordering twice equivalent to the original input?", "answer": "Because reverseBitOrdering is an involution: applying it twice restores the original bit sequence."}
{"id": 13, "type": "short", "question": "What does appending 0b01 to the message in sha3 M = Keccak`{d=digest} (M # 0b01) achieve?", "answer": "It provides domain separation and padding as required by FIPS-202 for SHA-3."}
{"id": 14, "type": "short", "question": "Describe what happens if the fin n constraint is removed from sha3 : {n} (fin n) => [n] -> [digest].", "answer": "Cryptol cannot reason about sequence length at compile time; functions depending on fixed size would fail type-checking."}
{"id": 15, "type": "short", "question": "What does SecurityStrength = DigestLength / 2 represent?", "answer": "The theoretical collision resistance of the hash, half the digest size in bits."}
{"id": 16, "type": "code", "question": "Complete the definition: sha3 M = Keccak`{d=digest} ( ____ )", "answer": "sha3 M = Keccak`{d=digest} (M # 0b01)"}
{"id": 17, "type": "code", "question": "Write a Cryptol property asserting that hashBytes and hash produce equivalent results on byte-aligned input.", "answer": "property hashBytes_vs_hash (M : [m][8]) = hashBytes M == split (hash (join M))"}
{"id": 18, "type": "code", "question": "Write the Cryptol REPL commands to load the SHA3 module and prove the above property for digest = 256.", "answer": ":load Primitive::Keyless::Hash::SHA3::SHA3\n:set digest = 256\n:prove hashBytes_vs_hash"}
{"id": 19, "type": "code", "question": "Define sha3_bytes that converts [m][8] to bits, applies sha3, and returns [digest/8][8].", "answer": "sha3_bytes : {m} (fin m) => [m][8] -> [digest/8][8]\nsha3_bytes M = split (sha3 (join M))"}
{"id": 20, "type": "code", "question": "Write a property that checks if M1 != M2 then hashBytes M1 != hashBytes M2, and explain why it cannot be proven in Cryptol.", "answer": "property collision_resistance (M1 M2 : [m][8]) = M1 != M2 ==> hashBytes M1 != hashBytes M2\nCannot be proven; requires cryptographic assumption beyond symbolic reasoning."}
